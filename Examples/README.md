# Course on Advanced programming for scientific computing Politecnico
# di Milano Copyright Luca Formaggia 2012

 **Changes AA 18019**

To semplify linking of dynamic libraries now I use in all cases the
 option -Wl-rpath=$(PACS_LIB_DIR), so that shared libs and
 executables that load dynamic libraries created by the Examples do
 not need to set LD_LIBRARY_PATH to work. Remember however that in
 general this is not the standard situation, dynamic libraries should
 be loaded following the loader rules explained in the lecture about
 static and dynamic libraries.

 *Note:* maybe some examples still follow the previous rule,
 where compiling with make target DEBUG=no(optimization activated)
 did not activate the -Wl,-rpath option above.

 **end Changes AA18-19**

#DOCUMENTATION#

Here you find the examples given in the course

`doc` -> possible additional documentation

`lib` -> possible general libraries needed to compile some example

`include` -> General include files

`src` -> Directory with the example sources

#INSTALLATION#

to compile the examples the first operation to be made is to copy the
file Makefile.user to Makefile.inc with

$ cp Makefile.user Makefile.inc

and edit the latter to suit your system.

All Makefiles of the examples include the file Makefile.inc in this
directory and possibly the Makefile.inc file local to the example
under consideration.  You may modify those files to suit your need.

In particular, the user may modify the Makefile.inc to change some
compilation options. The main Makefile.inc also sets the `PACS_ROOT`
variable, which should indicate the same directory where this `README.md`
file is kept (with full path, i.e. the path should start with `/`).  

You may change it to adapt the compilation process to your local settings by
editing the file (better choice) or by setting an environmental
variable with the same name: by setting the command 
```
export PACS_ROOT=myExampleDir 
```
in the `.profile` or `.bashrc` file in your home directory.

`Makefile.inc` is included in all the makefiles and it defines and
exports the following make macros:

- `PACS_ROOT` the directory where the Examples resides
- `CXX` the c++ compiler of choice
- `STANDARD` contains the C++ standard used in compilation
- `MPI_LIBDIR` and `MPI_INCDIR` where to find mpi libraries and header files, respectively
- `PACS_INC_DIR` and `PACS_LIB_DIR` directory for library and include files used by the examples, respectively
- `DOXYFILE` Location of the configuration file for DOxygen used in the examples
- `CPPFLAGS` Flags for the cpp preprocessor
- `CXXFLAGS` Flags for the c++ compiler
- `DEPEND` the file containing the autogenerated dependencies
- `LDFLAGS` Flags for the linker
- `LDLIBS` Common libraries (in the form `-Ldir -llib`)

Note that a local `Makefile.inc` may be contained (and included) in the
various directories when needed and it may override some of the macros
defined in the common `Makefile.inc`

I recall that any macro may be overrlued by specifying it when calling make
Example:
```
make CXXFLAGS+=-DSOMETHING LDFLAGS=SOMETHINGELSE
```
or by editing the corresponding `Makefile` (or, better, the `Makefile.inc`)

All examples are provided with a `Makefile` which accepts the following
options (some Makefile may have additional options, reported in the
`README.md` file specific for the example)

- `all` -makes the example
- `clean` -as it says
- `distclean` -clean and also deletes temporary file and local doc directory
- `doc` -creates directory doc and fills it with the documentation of the
example produced by doxygen. The file DoxiFileCommon contains the common 
doxygen configuration for all examples
- `library` - makes a library (whenever relevant)
- `install` -installs everithing in `PACS_LIB_DIR` and `PACS_INC_DIR`

Being all the first target of (almost all) the makefiles, to compile
the examples is often sufficient to type make. with make doc you
compile the documentation.

                *****   IMPORTANT  ****

To install some utilities used by different examples you must go to
src/Utilities and do

make
make install

in this way a library called libpacs.a (and ist dyanamic equivalent
libpacs.so) is installed in PACS_LIB_DIR and some header files are
installed in PACS_INC_DIR

# WORKING WITH MODULES (but also if you do not use them...)#

If you are using modules, some environmental variables are set by the
module system and will be inherited from the main `Makefile.inc` (the
one that you have created by copying Makefile.user).  In particular

- `mkEigenInc`    Where the Eigen libraries (infact the header files) is stored
- `mkOpenmpiLib`  The directory with the mpi libraries
- `mkOpenmpiInc`  The directory with the mpi headers
- `mkCxxCompiler` The c++ compiler of your choice

Other important environment variables set up by the module system that may be 
not  used in `Makefile.user` but may be used by other makefiles of the examples are

- `mkEigenHome`      Where the Eigen files are kept (normally equal to MkEigenInc)
- `mkClangSystemBin`  The directory holding all clang compiler executables 
- `mkCCompiler`       The C compiler of your choiche
- `mkSuitesparseLib`  Directory holding the libraries of the suitesparse suite (umfpack for instance)
- `mkSuitesparseInc`  Directory holding the header files of the suitesparse suite (umfpack for instance)
- `mkCgalLib`         Directory with the CGAL libraries (computational geometry libraries)
- `mkCgalInc`         Directory with the CGAL header files
- `mkBoostInc`        Directory with the boost libraries     
- `mkBoostLib`        Directory with the boost header files


So, you have two main choices

1) You use the module system provided with the virtual machine. Then
in your Makefile.inc you have to set only PACS_ROOT, all other
variables are set by the module system.  I recall that if you want to
see all environmental variables set by the modules you may do (all
variables starts with mk)

env | grep mk 

2) You do not use the module system. Then you have again two choices
 
   2.a) You set the various macro in your Makefile.inc (and possibly the other Makefiles, if needed) by yourself

   2.b) You simulate the module environment by creating the environmental variables: you have to put in the `.profile `file in your home directory the corresponding instructions
        for the bash (the `~/.profile` file is read by the bash shell every time you do a login). For example, in my `.profile` I have

        export mkEigenInc=/usr/local/include/eigen3
        export mkEigenHome=/usr/local/include/eigen3
        export mkOpenmpiLib=
        export mkClangSystemBin=/opt/clang3.7.1/bin
        export mkCCompiler=gcc
        export mkCxxCompiler=/opt/clang3.7.1/bin/clang++
        export mkSuitesparseLib=/usr/lib/x86_64-linux-gnu
        export mkSuitesparseInc=/usr/include/suitesparse/
        export mkCgalLib=/usr/lib
        export mkCgalInc=/usr/include
        export mkBoostInc=/usr/local/boost_1_57_0/include
        export mkBoostLib=/usr/local/boost_1_57_0/lib
        

        
        Remember that after you have modified your .profile file you
        need to do a new login (i.e. open a new shell) for the changes
        to be effective.

#FURTHER INFO#

- An overview of the examples is in the `CONTENT.md` file
- The bash script `directories.sh` creates a searcheable
tree, `directory.html` of the subfolder `src` that may be parsed with
a browser. To run it you must have the unix utility `tree`
installed. Anyway, a copy of `directories.html` is present in this directory.
